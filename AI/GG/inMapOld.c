/***************************************************************************** inMapTri.c    S.R.Lines    94.8.17-9.13 *****************************************************************************/#define         UNTIME  0#define         UNBUG   0#include        <stdio.h>#include        <stdlib.h>#include        <unFlags.h>#include        <unBug.h>#include        <unTypes.h>#include        <gl/gl.h>#include	<m/mj.h>#include	<winLoop.h>#include	<winDraw.h>#include        <m/rowCopy.h>#include        <m/mxyFwd.h>#include        "ggExtern.h"#include        "modFnTri.h"#include	"manCor.h"/**********#include        "inExtern.h"**********/#include        "inParm.h"#include        "mob.h"#include        "blerp.h"voidinMapTri2Old (pMD wwD, int nA, int nB, unt flags){static	flt 	fA[MAXPRS], fB[MAXPRS], fC[MAXPRS];static	unl	*gp,sA[MAXPRS], sB[MAXPRS], sC[MAXPRS];static	flt	triT[MAXTRI][12];pMOB 	mB = wwD->mob[nB];int 	numTri = mB->ntri;pDmj    dD  = wwD->dD;  int  dX = dD->x, dY = dD->y, dW = dD->w, dH = dD->h;pDmj    sD  = wwD->sD;  int  sX = sD->x, sY = sD->y, sW = sD->w, sH = sD->h;ppf 	dcT = wwD->dst, dwT = wwD->wts, *sRGB = wwD->sRGB, scA = sRGB[nA], scB = sRGB[nB];ppf 	baX = wwD->fvX[nB], baY = wwD->fvY[nB];ppf 	abX = wwD->bvX[nB], abY = wwD->bvY[nB];long	j;dbl	trs = 0.5, clr = 0.5, zoom = 1.0;flt 	*dp,*sp;pGlst	gA=NULL,gB=NULL,gC=NULL,gD=NULL,gE=NULL,gF=NULL;#if 1	/* kludge */static flt triP[TMAX][12];  for (j = 0; j < numTri; j++) {    dp = triP[j];    dp[0] = mB->triA[j][0][0];  dp[1] = mB->triA[j][0][1];    dp[2] = mB->triA[j][1][0];  dp[3] = mB->triA[j][1][1];    dp[4] = mB->triA[j][2][0];  dp[5] = mB->triA[j][2][1];    dp[6] = mB->triB[j][0][0];  dp[7] = mB->triB[j][0][1];    dp[8] = mB->triB[j][1][0];  dp[9] = mB->triB[j][1][1];    dp[10]= mB->triB[j][2][0];  dp[11]= mB->triB[j][2][1];  } #endif  wrn("BEG inMapTri2:     nA: %d   nB: %d     numTri: %d", nA, nB, numTri);  wrn("inMapTri2: dD: %d %d %u %u  sD: %d %d %u %u", dX,dY,dW,dH, sX,sY,sW,sH);  gA = (pGlst)calloc(1,sizeof(Glst));  gp = gA->rgba = &sA[0]; gA->glfn = &drawTris;  gA->stat = numTri; gA->glen = numTri*3;  dp = gA->glxy = &fA[0];  for (j = numTri; j-- ; gp += 3, dp += 6) {    sp     = triP[j];    dp[0]  = sp[0]*zoom;  dp[1]  = sp[1]*zoom;    dp[2]  = sp[2]*zoom;  dp[3]  = sp[3]*zoom;    dp[4]  = sp[4]*zoom;  dp[5]  = sp[5]*zoom;    gp[0]  = FcGRN;    gp[1]  = FcRED;    gp[2]  = FcBLU;  }  if (Options & O_VERB)  showF(sRGB[0],dX,dY,dW,dH,3,gA,"sRGB-A", 0, 1.0);  gB = (pGlst)calloc(1,sizeof(Glst));  gp = gB->rgba = &sB[0]; gB->glfn = &drawTris;  gB->stat = gB->glen = numTri*3;  dp = gB->glxy = &fB[0];  for (j = numTri; j-- ; gp += 3, dp += 6) {    sp     = &triP[j][6];    dp[0]  = sp[0]*zoom;  dp[1]  = sp[1]*zoom;    dp[2]  = sp[2]*zoom;  dp[3]  = sp[3]*zoom;    dp[4]  = sp[4]*zoom;  dp[5]  = sp[5]*zoom;    gp[0]  = FcYEL;    gp[1]  = FcCYN;    gp[2]  = FcMAG;  }  if (Options & O_VERB)  showF(sRGB[1],dX,dY,dW,dH,3,gB,"sRGB-B", 0, 1.0);  gC = (pGlst)calloc(1,sizeof(Glst));  gp = gC->rgba = &sC[0]; gC->glfn = &drawTris;  gC->stat = numTri; gC->glen = numTri*6;  dp = gC->glxy = &fC[0];  for (j = numTri; j-- ; gp += 3, dp += 6) {    sp     = triP[j];    dp[0]  = sp[0]*zoom;  dp[1]  = sp[1]*zoom;    dp[2]  = sp[2]*zoom;  dp[3]  = sp[3]*zoom;    dp[4]  = sp[4]*zoom;  dp[5]  = sp[5]*zoom;    gp[0]  = FcGRN;    gp[1]  = FcRED;    gp[2]  = FcBLU;    dp +=  6, sp += 6, gp += 3;    dp[0]  = sp[0]*zoom;  dp[1]  = sp[1]*zoom;    dp[2]  = sp[2]*zoom;  dp[3]  = sp[3]*zoom;    dp[4]  = sp[4]*zoom;  dp[5]  = sp[5]*zoom;    gp[0]  = FcYEL;    gp[1]  = FcCYN;    gp[2]  = FcMAG;  }    gD = (pGlst)calloc(1,sizeof(Glst));  gD->glxy = fC;  gD->rgba = sC; gD->glfn = &drawList; gD->stat = gD->glen = gC->glen;  gE = (pGlst)calloc(1,sizeof(Glst));  gE->glxy = fC;  gE->rgba = sC; gE->glfn = &drawList; gE->stat = gE->glen = gC->glen;  gF = (pGlst)calloc(1,sizeof(Glst));  gF->glxy = fC;  gF->rgba = sC; gF->glfn = &drawList; gF->stat = gF->glen = gC->glen;  if (Options & O_VERB) {    ixyFwd2(dcT,dwT,scA,scB,baX,baY,dX,dY,dW,dH,sX,sY,sW,sH,O_BLNR,trs,clr,InFill,127.5);    showF(dcT,dX,dY,dW,dH,3,gC,"ixyFwd2  trs==0.5", 0 , 1.0);  }  if (baX && baY) {    copyFlowToUndo(wwD,mB->foX,mB->foY,nB);    for (j = 0; j < numTri; j++) {      sp = triP[j];      dp = triT[j];#if 1      dp[0] = mB->triA[j][0][0];	dp[ 6] = dp[0] - mB->triB[j][0][0];      dp[1] = mB->triA[j][0][1];	dp[ 7] = dp[1] - mB->triB[j][0][1];      dp[2] = mB->triA[j][1][0];	dp[ 7] = dp[2] - mB->triB[j][1][0];      dp[3] = mB->triA[j][1][1];	dp[ 7] = dp[3] - mB->triB[j][1][1];      dp[4] = mB->triA[j][2][0];	dp[ 7] = dp[4] - mB->triB[j][2][0];      dp[5] = mB->triA[j][2][1];	dp[ 7] = dp[5] - mB->triB[j][2][1];#else      dp[0] = sp[0];	dp[ 6] = sp[0] - sp[ 6];      dp[1] = sp[1];	dp[ 7] = sp[1] - sp[ 7];      dp[2] = sp[2];	dp[ 8] = sp[2] - sp[ 8];      dp[3] = sp[3];	dp[ 9] = sp[3] - sp[ 9];      dp[4] = sp[4];	dp[10] = sp[4] - sp[10];      dp[5] = sp[5];	dp[11] = sp[5] - sp[11];#endif    }    triModFn2(baX,baY,triT,numTri);  }  if (abX && abY) {    wrn("inMapTri2: abX & abY are non-NULL; should look for reverse MC file...");  }  /******  if (Options & O_VERB)    showF(dcT,dX,dY,dW,dH,3,gD,"ixyFwd2  MODIFIED  0.5" , 0 , 1.0);  ixyFwd2(dcT,dwT,scA,scB,baX,baY,dX,dY,dW,dH,sX,sY,sW,sH,O_BLNR,trs,clr,InFill,127.5);  showF(dcT,dX,dY,dW,dH,3,gE,"ixyFwd2  MANUAL CORRESP  0.5",0 , 1.0);  *******/#if 1#else  winLoopSgi();#endif}pWmjshowTri( ppu inpU[4],  LblFace *lbl, pDmj iD, char *wtitle, AffTrf *aft, pGlst *pGL, flt triP[][12], int numTri, unt flags){static  unl     sA[MAXPRS], sB[MAXPRS];long    j;      unl *gp;flt     *dp,*sp;                                        /* yT = iD->h - 1.0; */pGlst   pG = *pGL = (pGlst)calloc(1,sizeof(Glst));  if (flags) gp = &sB[0]; else gp = &sA[0];  pG->rgba = gp;  pG->glxy = dp = (pfl)calloc(MAXPRS,sizeof(flt));  pG->stat = numTri;  pG->glen = numTri*3;  pG->glfn = &drawTris;  wrn("begin showItWithTri: TRIANGLES: %d",numTri);  for (j = 0; j < numTri; j++, gp += 3, dp += 6) {    if (flags) {      sp     = &triP[j][6];      gp[0]  = FcYEL;      gp[1]  = FcCYN;      gp[2]  = FcMAG;    } else {      sp     = &triP[j][0];      gp[0]  = FcGRN;      gp[1]  = FcRED;      gp[2]  = FcBLU;    }#if 1    dp[0]  = sp[0]*Zoom;  dp[1]  = sp[1]*Zoom;    dp[2]  = sp[2]*Zoom;  dp[3]  = sp[3]*Zoom;    dp[4]  = sp[4]*Zoom;  dp[5]  = sp[5]*Zoom;#else    dp[0]  = sp[0]*Zoom;  dp[1]  = (yT - sp[1])*Zoom;    dp[2]  = sp[2]*Zoom;  dp[3]  = (yT - sp[3])*Zoom;    dp[4]  = sp[4]*Zoom;  dp[5]  = (yT - sp[5])*Zoom;#endif  }  return showU(inpU,iD->x,iD->y,iD->w,iD->h,iD->d,pG,wtitle,0);}pWmjshowDots(ppu src[4], LblFace *lbl, pDmj sD, char *wtitle, AffTrf *aft, pGlst *pGL){static  unl     *gp, sA[MAXPRS];int     sW = sD->w, sH = sD->h;pfl     dp;pGlst   pG = *pGL = (pGlst)calloc(1,sizeof(Glst));  pG->rgba = gp = &sA[0]; pG->glfn = &drawTrisOld; /* drawTrisOld */  pG->glxy = dp = (pfl)calloc(MAXPRS,sizeof(flt));  pG->stat = 3;  pG->glen = 3*3;  gp[0]  = FcCLR[0%6];  gp[1]  = FcCLR[1%6];  gp[2]  = FcCLR[2%6];  gp[3]  = FcCLR[3%6];  dp[0]  = sW * lbl->lex*Zoom;  dp[1]  = sH * lbl->ley*Zoom; wrn("DOTS 1: %.3f %.3f --> %.3f %.3f",lbl->lex,lbl->ley,dp[0],sH-dp[1]);  dp[2]  = sW * lbl->rex*Zoom;  dp[3]  = sH * lbl->rey*Zoom; wrn("DOTS 2: %.3f %.3f --> %.3f %.3f",lbl->rex,lbl->rey,dp[2],sH-dp[3]);  dp[4]  = sW * lbl->nox*Zoom;  dp[5]  = sH * lbl->noy*Zoom; wrn("DOTS 3: %.3f %.3f --> %.3f %.3f",lbl->nox,lbl->noy,dp[4],sH-dp[5]);  dp[6]  = sW * lbl->mex*Zoom;  dp[7]  = sH * lbl->mey*Zoom; wrn("DOTS 4: %.3f %.3f --> %.3f %.3f",lbl->mex,lbl->mey,dp[6],sH-dp[7]);  return showU(src,sD->x,sD->y,sD->w,sD->h,sD->d,*pGL,wtitle,0);}int mobDrawTri (void *vp){pGlst   G = (pGlst) vp;int     j = G->glen/3;punl    rgba = G->rgba;flt     *fxy = G->glxy;long    sfactr=BF_SA, dfactr=BF_SA;  while (j--) {    blendfunction(sfactr,dfactr);    bgnpolygon();      cpack(rgba[0] & 0x7FFFFFFF); v2f(&fxy[0]);      cpack(rgba[1] & 0x7FFFFFFF); v2f(&fxy[2]);      cpack(rgba[2] & 0x7FFFFFFF); v2f(&fxy[4]);    endpolygon();    blendfunction(BF_ONE,BF_ZERO);    cpack(rgba[0]); circ(fxy[0],fxy[1],2.0);    cpack(rgba[1]); circ(fxy[2],fxy[3],2.0);    cpack(rgba[2]); circ(fxy[4],fxy[5],2.0);    fxy += 6, rgba += 3;  }  return G->glen/3;}