voidmmGridTet (void *v, int device, int flags){pWmj    wA   = (pWmj)v;pWmj    wB   = wA->next;WmjAct *ap   =  wA->act;pMD     wwD  = (pMD)ap->data;int     nB   = ap->nB;  pMOB  mB = wwD->mob[nB];long    orgX, orgY, wd, ht;long    xAn,yAn, xBn,yBn;long    widA = wA->id, widB = wB->id;ppf     floX = mB->foX;ppf     floY = mB->foY;int     j, k, jB,kB;	unt clr;flt     zX   = wA->zX, zY   = wA->zY;dbl     rX   = 1.0/zX, rY = 1.0/zY;flt 	*xyA, *xyB, fxy[2], dx, dy, dist2, mind2 = 10e6;  if (!flags)  return;  getsize(&wd,&ht);     wd -= 1, ht -= 1;  getorigin(&orgX,&orgY);  xAn  = (getvaluator(MOUSEX) - orgX);  yAn  = (getvaluator(MOUSEY) - orgY);  /*wrn("THIS IS markGridTet: xAn,yAn == %d , %d", xAn,yAn);*/  dx = xAn - xAo;  dy = yAn - yAo;  dist2 = dx*dx + dy*dy;  if (dist2 > 33.0) for (  j = 0; j <= GrdY; j++) {  /* if close, pick prev. */    for (k = 0; k <= GrdX; k++) {      xyA = mB->grdA[j][k].xy;      dx  = xAn - xyA[0];      dy  = yAn - xyA[1];      dist2 = dx*dx + dy*dy;      if (dist2 < mind2) {        mind2 = dist2;        jm  = j;        km  = k;      }    }  }  /* Corner points can't move at all... */  if        (jm == 0  ) {    if      (km == 0  )  jm = km = 1;    else if (km == GrdX) jm = 1,  km = Km;  }  else if   (jm == GrdY) {    if      (km == 0  )  jm = Jm, km = 1;    else if (km == GrdX) jm = Jm, km = Km;  }  j = jm, k = km;  winset(widB);  drawmode(OVERDRAW);  color(BLACK);  circi(xBo,yBo,rv0);	/* Erase mark (in B) from last touched grid node */  xyB = mB->grdB[jm][km].xy;  xBo = xyB[0];  yBo = xyB[1];  if (MoveGridB) FLINES(mB->grdB,xyB,jm,km);  winset(widA);  cursoff();  drawmode(OVERDRAW);  color(BLACK);  circi(xAo,yAo,rv0);	/* Erase mark (in A) from last touched grid node */  xyA = mB->grdA[jm][km].xy;  clr = mB->grdA[jm][km].clr;  xAo = xyA[0];  yAo = xyA[1];  FLINES(mB->grdA,xyA,jm,km);  while(getbutton(device)) {    xAn = getvaluator(MOUSEX) - orgX;    yAn = getvaluator(MOUSEY) - orgY;    if (km == 0) xAn = 0; else if (km == GrdX)       xAn = wd  ;    else if (xAn < 1) xAn = 1; else if (xAn >= wd)  xAn = wd-1;    if (jm == 0) yAn = 0; else if (jm == GrdY)       yAn = ht  ;    else if (yAn < 1) yAn = 1; else if (yAn >= ht)  yAn = ht-1;    if (xAn != xAo || yAn != yAo) {      if (MoveGridB)  {        if (UseFlowAB) {          kB = xAn*rX + 0.5;          jB = yAn*rY + 0.5;          xBn = xAn - zX * floX[jB][kB];          yBn = yAn - zY * floY[jB][kB];        }        else {          xBn = xyB[0] + (xAn - xyA[0]);  /* make proportional to spacing in B */          yBn = xyB[1] + (yAn - xyA[1]);        }        if (xBn < 0)  xBn = 0;  else if (xBn > wd)  xBn = wd;        if (yBn < 0)  yBn = 0;  else if (yBn > ht)  yBn = ht;        winset(widB);        color(BLACK);        fxy[0] = xBo, fxy[1] = yBo;         FLINES(mB->grdB,fxy,jm,km);        color(clr);        fxy[0] = xBn, fxy[1] = yBn;         FLINES(mB->grdB,fxy,jm,km);        xBo = xBn, yBo = yBn;        winset(widA);      }      color(BLACK);      fxy[0] = xAo, fxy[1] = yAo;       FLINES(mB->grdA,fxy,jm,km);      color(clr);      fxy[0] = xAn, fxy[1] = yAn;       FLINES(mB->grdA,fxy,jm,km);      xAo = xAn, yAo = yAn;    }  }  xyA[0] = xAn;	/* mB->grdA[jm][km].xy[0] = xAn; */  xyA[1] = yAn;	/* mB->grdA[jm][km].xy[1] = yAn; */  if (MoveGridB) {    mB->grdB[jm][km].xy[0] = xBn;    mB->grdB[jm][km].xy[1] = yBn;  }  winset(widB);  xBo = xyB[0] + 0.5;  yBo = xyB[1] + 0.5;  color(GREEN); circi(xBo,yBo,rv0);	/* Mark (in B) last grid node moved */  drawmode(NORMALDRAW);  winset(widA);  color(GREEN); circi(xAo,yAo,rv0);	/* Mark (in A) last grid node moved */  drawmode(NORMALDRAW);  drawGridTet2(wA,device, (flags|1));  curson();}#if 0000voidmoveGridTet (void *v, int device, int flags){pWmj    wB   = (pWmj)v;pWmj    wA   = wB->next;WmjAct *ap   =  wB->act;pMD     wwD  = (pMD)ap->data;int     nB   = ap->nB;  pMOB  mB = wwD->mob[nB];   unt clr;long    widA = wA->id, widB = wB->id;long    j,k, orgX, orgY, wd, ht;long    xBn,yBn, xm,xM,  ym,yM;flt 	*xyA, *xyB, fxy[2], dx, dy, dist2, mind2 = 10e6;  if (!flags)  return;  getsize(&wd,&ht);     wd -= 1, ht -= 1;  getorigin(&orgX,&orgY);  xBn  = (getvaluator(MOUSEX) - orgX);  yBn  = (getvaluator(MOUSEY) - orgY);  /*wrn("THIS IS moveGridTet: xBn,yBn == %d , %d", xBn,yBn);*/  dx = xBn - xBo;  dy = yBn - yBo;  dist2 = dx*dx + dy*dy;  if (dist2 > 33.0)  for (j = 0; j <= GrdY; j++) {  /* if close, pick prev. */    for (k = 0; k <= GrdX; k++) {      xyB = mB->grdB[j][k].xy;      dx  = xBn - xyB[0];      dy  = yBn - xyB[1];      dist2 = dx*dx + dy*dy;      if (dist2 < mind2) {        mind2 = dist2;        jm  = j;        km  = k;      }    }  }  /* Corner points can't move at all... */  if        (jm == 0  ) {    if      (km == 0  )  jm = km = 1;    else if (km == GrdX) jm = 1,  km = Km;  }  else if   (jm == GrdY) {    if      (km == 0  )  jm = Jm, km = 1;    else if (km == GrdX) jm = Jm, km = Km;  }  j = jm, k = km;  cursoff();  winset(widA);  drawmode(OVERDRAW);  color(BLACK);  circi(xAo,yAo,rv0);		/* Erase mark (in A) from last moved */  winset(widB);  drawmode(OVERDRAW);  color(BLACK);  circi(xBo,yBo,rv0);		/* Erase mark (in B) from last moved */  clr = mB->grdB[jm][km].clr;  xyB = mB->grdB[jm][km].xy;  xBo = xyB[0];  yBo = xyB[1];  FLINES(mB->grdB,xyB,jm,km);/* determine limits of this grid point's mobility */  if 	  (jm == 0  )	ym = yM = 0 ;  else if (jm == GrdY)	ym = yM = ht;  else {    xyB = mB->grdB[j-1][k  ].xy;	ym = xyB[1] + 1;    xyB = mB->grdB[j+1][k  ].xy;	yM = xyB[1] - 1;  }  if 	  (km == 0  )	xm = xM = 0 ;  else if (km == GrdX)	xm = xM = wd;  else {    xyB = mB->grdB[j  ][k-1].xy;	xm = xyB[0] + 1;    xyB = mB->grdB[j  ][k+1].xy;	xM = xyB[0] - 1;    /*    xyB = mB->grdB[j-1][k  ].xy;	ym = xyB[1] + 1;    xyB = mB->grdB[j+1][k  ].xy;	yM = xyB[1] - 1;    */  }  while(getbutton(device)) {    xBn = getvaluator(MOUSEX) - orgX;    yBn = getvaluator(MOUSEY) - orgY;    if (xBn < xm)  xBn = xm;   else if (xBn > xM)  xBn = xM;    if (yBn < ym)  yBn = ym;   else if (yBn > yM)  yBn = yM;    if (xBn != xBo || yBn != yBo) {      color(BLACK);      fxy[0] = xBo, fxy[1] = yBo;       FLINES(mB->grdB,fxy,jm,km);      color(clr);      fxy[0] = xBn, fxy[1] = yBn;       FLINES(mB->grdB,fxy,jm,km);      xBo = xBn, yBo = yBn;    }  }  mB->grdB[jm][km].xy[0] = xBn;  mB->grdB[jm][km].xy[1] = yBn;  winset(widA);  xyA = mB->grdA[jm][km].xy;  xAo = xyA[0];  yAo = xyA[1];  color(GREEN); circi(xAo,yAo,rv0);	/* Mark (in A) last grid node moved */  drawmode(NORMALDRAW);  winset(widB);  color(GREEN); circi(xBo,yBo,rv0);	/* Mark (in B) last grid node moved */  drawmode(NORMALDRAW);  drawGridTet2(wB,device, (flags|2));  curson();}#endif /* 0000 */